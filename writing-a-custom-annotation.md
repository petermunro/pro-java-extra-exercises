# Writing a Custom Annotation

## Purpose

This exercise is to help you understand annotations and how they can be used for a variety of use cases. This one is for logging and monitoring.

You will create a custom annotation (`@LogExecution`) to log the execution time of a method, its input parameters, and return values.

## Steps

1. Create a custom annotation `@LogExecution` with the retention policy set to runtime and the target set to methods.

2. Create an interface, `MethodLogger`, with a method called `logMethodExecution`.

3. Implement the `MethodLogger` interface in a class, `MethodLoggerImpl`. In the `logMethodExecution` method, use reflection to log the method execution time, input parameters, and return values of methods annotated with `@LogExecution`.

4. Create a test class, `LogExecutionTest`, with a few methods that have different input parameters and return values.

5. Annotate some of the methods in the `LogExecutionTest` class with the `@LogExecution` annotation.

6. Write a test runner class, `TestRunner`, with a `main` method to execute the `LogExecutionTest` class and observe the logs generated by the `MethodLoggerImpl`.

---

## Detailed Steps

1. Create the custom annotation `@LogExecution`:

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecution {
}
```

2. Create the `MethodLogger` interface:

```java
public interface MethodLogger {
    void logMethodExecution(Object target, String methodName, Object... args) throws Exception;
}
```

3. Implement the `MethodLoggerImpl` class:

```java
import java.lang.reflect.Method;

public class MethodLoggerImpl implements MethodLogger {

    @Override
    public void logMethodExecution(Object target, String methodName, Object... args) throws Exception {
        Class<?> targetClass = target.getClass();
        Method[] methods = targetClass.getDeclaredMethods();

        for (Method method : methods) {
            if (method.getName().equals(methodName) && method.isAnnotationPresent(LogExecution.class)) {
                long startTime = System.currentTimeMillis();

                System.out.println("Executing method: " + methodName + ", with arguments: " + Arrays.toString(args));

                Object result = method.invoke(target, args);

                long endTime = System.currentTimeMillis();
                System.out.println("Method execution took: " + (endTime - startTime) + " ms, and returned: " + result);
            }
        }
    }
}
```

4. Create the `LogExecutionTest` class:

```java
public class LogExecutionTest {

    @LogExecution
    public void method1(String param1, int param2) {
        // Some implementation
    }

    public int method2(int num) {
        // Some implementation
        return num * 2;
    }

    @LogExecution
    public String method3(String input) {
        // Some implementation
        return input.toUpperCase();
    }
}
```

5. Annotate the methods in the `LogExecutionTest` class as shown above.

6. Write the `TestRunner` class with a main method:

```java
public class TestRunner {

    public static void main(String[] args) throws Exception {
        LogExecutionTest test = new LogExecutionTest();
        MethodLogger logger = new MethodLoggerImpl();

        logger.logMethodExecution(test, "method1", "Hello", 42);
        logger.logMethodExecution(test, "method2", 5);
        logger.logMethodExecution(test, "method3", "world");
    }
}
```

7. Run the `TestRunner` class and observe the logs generated by the `MethodLoggerImpl` for the methods annotated with `@LogExecution`.
